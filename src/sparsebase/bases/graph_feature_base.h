#include "sparsebase/preprocess/preprocess.h"
#include "sparsebase/feature/degrees.h"
#include "sparsebase/feature/degree_distribution.h"
#include <algorithm>
#include <iostream>
#include <limits>
#include <map>
#include <memory>
#include <queue>
#include <set>
#include <tuple>
#include <unordered_map>
#include <utility>
#include <vector>
#ifndef SPARSEBASE_PROJECT_GRAPH_FEATURE_BASE_H
#define SPARSEBASE_PROJECT_GRAPH_FEATURE_BASE_H

namespace sparsebase::bases {

class GraphFeatureBase {
 public:
  //! Calculates the degree distribution of every vertex represented by the
  //! FormerOrderTwo object `format`.
  /*!
   * @tparam FeatureType data type used for storing degree distribution values.
   * @param format FormatOrderTwo object representing a graph.
   * @param contexts vector of contexts that can be used for permutation.
   * @param convert_input whether or not to convert the input format if that is
   * needed.
   * @return an array of type `FeatureType*` size format->get_dimensions()[0]
   * with the degree distribution of each vertex.
   */
  template <typename FeatureType, typename AutoIDType, typename AutoNNZType,
      typename AutoValueType>
  static FeatureType *GetDegreeDistribution(
      format::FormatOrderTwo<AutoIDType, AutoNNZType, AutoValueType> *format,
      std::vector<context::Context *> contexts, bool convert_input) {
    feature::DegreeDistribution<AutoIDType, AutoNNZType, AutoValueType, FeatureType>
        deg_dist;
    return deg_dist.GetDistribution(format, contexts, convert_input);
  }

  //! Calculates the degree distribution of every vertex represented by the
  //! FormerOrderTwo object `format` with cached output.
  /*!
   * @tparam FeatureType data type used for storing degree distribution values.
   * @param format FormatOrderTwo object representing a graph.
   * @param contexts vector of contexts that can be used for permutation.
   * @return An std::pair with the second element being an array of type
   * `FeatureType*` size format->get_dimensions()[0] with the degree
   * distribution of each vertex, and the first being a vector of all the
   * formats generated by converting the input (if such conversions were needed
   * to execute the permutation).
   */
  template <typename FeatureType, typename AutoIDType, typename AutoNNZType,
      typename AutoValueType>
  static std::pair<std::vector<format::FormatOrderTwo<AutoIDType, AutoNNZType,
      AutoValueType> *>,
  FeatureType *>
  GetDegreeDistributionCached(
      format::FormatOrderTwo<AutoIDType, AutoNNZType, AutoValueType> *format,
  std::vector<context::Context *> contexts) {
    feature::DegreeDistribution<AutoIDType, AutoNNZType, AutoValueType, FeatureType>
        deg_dist;
    auto output = deg_dist.GetDistributionCached(format, contexts, true);
    std::vector<
    format::FormatOrderTwo<AutoIDType, AutoNNZType, AutoValueType> *>
                                                    converted_formats;
    std::transform(
        std::get<0>(output)[0].begin(), std::get<0>(output)[0].end(),
        std::back_inserter(converted_formats),
        [](format::Format *intermediate_format) {
          return static_cast<
              format::FormatOrderTwo<AutoIDType, AutoNNZType, AutoValueType> *>(
              intermediate_format);
        });
    return std::make_pair(converted_formats, std::get<1>(output));
  }
  //! Calculates the degree count of every vertex represented by the
  //! FormerOrderTwo object `format`.
  /*!
   * @param format FormatOrderTwo object representing a graph.
   * @param contexts vector of contexts that can be used for permutation.
   * @param convert_input whether or not to convert the input format if that is
   * needed.
   * @return an array of size format->get_dimensions()[0] with the degree of
   * each vertex.
   */
  template <typename AutoIDType, typename AutoNNZType, typename AutoValueType>
  static AutoNNZType *GetDegrees(
      format::FormatOrderTwo<AutoIDType, AutoNNZType, AutoValueType> *format,
      std::vector<context::Context *> contexts, bool convert_input) {
    feature::Degrees<AutoIDType, AutoNNZType, AutoValueType> deg_dist;
    return deg_dist.GetDegrees(format, contexts, convert_input);
  }
  //! Calculates the degree count of every vertex represented by the
  //! FormerOrderTwo object `format` with cached output.
  /*!
   * @param format FormatOrderTwo object representing a graph.
   * @param contexts vector of contexts that can be used for permutation.
   * @param convert_input whether or not to convert the input format if that is
   * needed.
   * @return An std::pair with the second element being an array of type
   * `FeatureType*` size format->get_dimensions()[0] with the degree of each
   * vertex, and the first being a vector of all the formats generated by
   * converting the input (if such conversions were needed to execute the
   * permutation).
   */
  template <typename AutoIDType, typename AutoNNZType, typename AutoValueType>
  static std::pair<std::vector<format::FormatOrderTwo<AutoIDType, AutoNNZType,
      AutoValueType> *>,
  AutoNNZType *>
  GetDegreesCached(
      format::FormatOrderTwo<AutoIDType, AutoNNZType, AutoValueType> *format,
  std::vector<context::Context *> contexts) {
    feature::Degrees<AutoIDType, AutoNNZType, AutoValueType> deg_dist;
    auto output = deg_dist.GetDegreesCached(format, contexts, true);
    std::vector<
    format::FormatOrderTwo<AutoIDType, AutoNNZType, AutoValueType> *>
                                                    converted_formats;
    std::transform(
        std::get<0>(output)[0].begin(), std::get<0>(output)[0].end(),
        std::back_inserter(converted_formats),
        [](format::Format *intermediate_format) {
          return static_cast<
              format::FormatOrderTwo<AutoIDType, AutoNNZType, AutoValueType> *>(
              intermediate_format);
        });
    return std::make_pair(converted_formats, std::get<1>(output));
  }
};
}

#endif  // SPARSEBASE_PROJECT_GRAPH_FEATURE_BASE_H
