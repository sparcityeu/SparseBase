
.. _program_listing_file_src_sparsebase_feature_feature.h:

Program Listing for File feature.h
==================================

|exhale_lsh| :ref:`Return to documentation for file <file_src_sparsebase_feature_feature.h>` (``src/sparsebase/feature/feature.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /*******************************************************
    * Copyright (c) 2022 SparCity, Amro Alabsi Aljundi, Taha Atahan Akyildiz, Arda Sener
    * All rights reserved.
    *
    * This file is distributed under MIT license.
    * The complete license agreement can be obtained at:
    * https://sparcityeu.github.io/sparsebase/pages/license.html
    ********************************************************/
   #ifndef SPARSEBASE_SPARSEBASE_FEATURE_FEATURE_H_
   #define SPARSEBASE_SPARSEBASE_FEATURE_FEATURE_H_
   
   #include "sparsebase/format/format.h"
   #include "sparsebase/preprocess/preprocess.h"
   #include <any>
   #include <set>
   #include <tuple>
   #include <unordered_map>
   #include <vector>
   
   namespace sparsebase::feature {
   
   template <typename Interface> struct Implementation {
   public:
     Implementation() = default;
     template <typename ConcreteType>
     explicit Implementation(ConcreteType &&object)
         : storage{std::forward<ConcreteType>(object)},
           getter{[](std::any &storage) -> Interface & {
             return std::any_cast<ConcreteType &>(storage);
           }} {}
     Implementation(const Implementation &object)
         : storage{object.storage}, getter{object.getter} {}
     Implementation(Implementation &&object) noexcept
         : storage{std::move(object.storage)}, getter{std::move(object.getter)} {}
     Implementation &operator=(Implementation other) {
       storage = other.storage;
       getter = other.getter;
       return *this;
     }
   
     Interface *operator->() { return &getter(storage); }
   
   private:
     std::any storage;
     Interface &(*getter)(std::any &);
   };
   
   using Feature = Implementation<preprocess::ExtractableType>;
   
   template <class ClassType, typename Key = std::vector<std::type_index>,
             typename KeyHash = preprocess::TypeIndexVectorHash,
             typename KeyEqualTo = std::equal_to<std::vector<std::type_index>>>
   class ClassMatcherMixin {
   
   #ifdef DEBUG
   public:
   #else
   protected:
   #endif
   
     std::unordered_map<Key, ClassType, KeyHash, KeyEqualTo> map_;
     void RegisterClass(std::vector<std::type_index> instants, ClassType);
     std::tuple<ClassType, std::vector<std::type_index>>
     MatchClass(std::unordered_map<std::type_index, ClassType> &source,
                std::vector<std::type_index> &ordered, unsigned int K);
     void GetClassesHelper(std::unordered_map<std::type_index, ClassType> &source,
                           std::vector<std::type_index> &ordered,
                           std::vector<ClassType> &res);
     std::vector<ClassType>
     GetClasses(std::unordered_map<std::type_index, ClassType> &source);
   };
   
   
   class Extractor : public ClassMatcherMixin<preprocess::ExtractableType *> {
   public:
     ~Extractor();
   
     static std::unordered_map<std::type_index, std::any>
     Extract(std::vector<Feature> &features, format::Format *format,
             const std::vector<context::Context *> &);
     std::
         unordered_map<std::type_index, std::any>
   
         Extract(format::Format *format,
                 const std::vector<context::Context *> &con);
   
     void Add(Feature f);
   
     void Subtract(Feature f);
   
     std::vector<std::type_index> GetList();
   
     void PrintFuncList();
     std::vector<preprocess::ExtractableType *> GetFuncList();
   
   protected:
     Extractor() noexcept = default;
   
   private:
   
     std::unordered_map<std::type_index, preprocess::ExtractableType *> in_;
   };
   
   template <typename IDType, typename NNZType, typename ValueType,
             typename FeatureType>
   class FeatureExtractor : public Extractor {
   public:
     FeatureExtractor();
   };
   
   } // namespace sparsebase::feature
   
   #ifdef _HEADER_ONLY
   #include "sparsebase/feature/feature.cc"
   #endif
   
   #endif // SPARSEBASE_SPARSEBASE_FEATURE_FEATURE_H_
